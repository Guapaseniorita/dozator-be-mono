# Дозатор Backend
Бэкенд состоит из нескольких модулей. Основные модули:
- **dozator/domain** - сущности и репозитории
- **dozator/dozator-api** - spring-сервисы и контроллеры
- **dozator/dto** - DTO дозаторов
- **dozator/migrations** - миграции Liquibase
- **common** - утилиты
- **buildScr** - константы для докер-образа

## Реализация нового дозатора
Реализация существующих дозаторов отличается от дозатора к дозатору (не все дозаторы подвергались рефакторингу), но суть реализации у всех одна.

**Алгоритм реализации нового дозатора**:

1. В модуле **dozator/domain**:
- добавить тип дозатора в класс *DispenserType* по аналогии с другими константами в классе;
- написать сущности для дозатора;
- написать класс для формирования результата по дозе;
- написать репозитории.
2. В модуле **dozator/dto**:
- написать DTO-класс;
- добавить написанный DTO-класс к аргументам аннотации *JsonSubTypes*, которая стоит над классом *CalculateDoseRequest*.
3. В модуле **dozator/dozator-api**:
- написать сервисы с логикой для каждой ветки дозатора;
- *опционально* написать контроллер для извлечения данных по дозаторам из базы данных.

## DispenserType

Константа DispenserType **используется в DTO и в сервисах**.
В дозаторе есть один endpoint, через который фронт отправляет бэку запрос дозатору (см. контроллер *DoseController*).

В случае DTO поле type типа DispenserType используется как свойство-дискриминатор запроса, т.е. по нему определяется в объект какого типа нужно парсить тело запроса.

В случае сервисов поле type типа DispenserType используется для идентификации сервиса. См. далее **Логика дозатора**.

## Сущности

Если дозатор можно сгруппировать по группам (веткам), рекомендуется создавать абстрактную сущность с общими для каждой группы элементами и потом расширять эту сущность для каждой группы.

Общие компоненты всех дозаторов: **id** и **result**, - соответственно, идентификатор и результат.
Дозаторы хранятся в базе данных mongo, поэтому все сущности должны быть помечены аннотацией *@Document*.

Рекомендуется создавать класс c припиской *Declaration* с определением всех полей веток дозатора в интерфейсах, чтобы не путаться в полях при присвоении полей DTO соответствующим полям сущности. В будущем желательно написать mapper.

## Результат вычисления дозы

Класс-компонент с возможными результатами обычно пишется в файле с сущностью и называется с припиской *Result*. Класс наследует от *DispenserResultBuilder* (хотя по факту не является билдером) и содержит перечисление *Type* и  единственный метод *by*, принимающий тип результата и дозы, которые расставляются по текстовке результата).

Метод возвращает объект *DispenserResult* и содержит:
- **name** - рудимент от бывшей реализации в виде перечисления, можно использовать, чтобы дать имя результату;
- **dose** - текстовка с дозировкой (итог, выводится крупным шрифтом на фронте);
- **description** - описание результата;
- important - важное описание (**не используется!!!**).

Описание можно сформировать с помощью класса *Description*. Его конструктор, а также его метод *add* принимают текстовое описание абзаца (*description*), его заголовок (*caption*, опционально) и флаг важности (*important*, опционально; на фронте приписывается пометка "Важно!"; замена полю *important* в *DispenserResult*).

**Пример**:
```
 Type.DEXTRAN -> DefaultDispenserResult(  
    name = type.name,  
	dose = "${doses[0]}",  
	description = Description("Железа (III) гидроксид декстран")  
        .add("${doses[0]} железа", caption = "Ориентировочная курсовая доза")  
        .add("Внесите ориентировочную дозу в карту пациента")  
        .add("Ампул на курс: ${doses[1]} по 100 мг")  
        .add("Ампула: 100 мг Fe в 2 мл")  
        .add("Концентрация: 50 мг/мл")  
        .add(  
            caption = "Торговое наименование",  
			description = "Монофер")  
        .add(  
            caption = "Внутривенно капельно",  
			description = """  
				 1. Введение 100-200 мг железа (2-4 мл препарата) 2-3 раза в неделю. 2. Максимально допустимая разовая доза: ${doses[2]} в/в капельно, развести на 400 мл 0,9% NaCl, вводить с максимальной скоростью 45-60 капель/мин, в течение 1 часа наблюдать за пациентом. Для инъекции необходимо ${doses[3]} развести на 400 мл 0,9% NaCl. Максимальная разовая доза рассчитана с учетом курсовой и верхних ограничений по дозировке.
			""".trimIndent())  
        .add(  
            caption = "Кратность приёма",  
			description = "1 раз в неделю при введении максимальной допустимой дозы")  
        .add(  
            caption = "Введение внутривенно струйно",  
			description = """  
				 100-200 мг железа (2 или 4 мл препарата), продолжительность введения не менее 20 минут, 2-3 раза в неделю. Перед введением развести на 10-20 мл 0,9% NaCl.
			 """.trimIndent())
		.items  
)
```

Как видно из примера, дозы расставляются как в текстовки с итоговой дозой, так и в описании.

*DosePresenter* имеет две реализации: *Dose* с расширением *DoseRange* и *StringValue*. Последняя позволяет передать простую строку без обработок. *Dose* принимает в конструкторе числовое значение и конфигурацию. Через конфигурацию задаются параметры для обработки числового значения. Можно задать минимальное и максимальное значение дозы, указать единицу измерения, которая будет приписана в строковом представлении дозы, количество нулей после запятой для чисел с плавающей точкой. *DoseRange* позволяет сформировать дозу в виде диапазон значений.

## Репозитории

Репозитории создаются как стандартные spring-repository. У каждой сущности должно быть по репозиторию. Реализовать репозитории можно по аналогии с имеющимися дозаторами.

Репозитории настроены так, чтобы каждый из них через *findAll()* возвращал значения именно той сущности, к которой он привязан.

Можно посмотреть, как они используются, в контроллерах дозаторов в модуле **dozator/dozator-api**.

## DTO

DTO создаются на основе класса *CalculateDoseRequest* в модуле **dozator/dozator-api**. Чтобы создать DTO, необходимо:
- создать абстрактный класс DTO для дозатора и повесить на него аннотации *@JsonSubTypes* с указанием подтипов (для каждой ветки по типу) и *@Schema* для отображения в Swagger;
- создать наследующие классы для каждой ветки, у каждого такого класса указать тип *DispenserType*;
- добавить **абстрактный** класс в параметры аннотации *@JsonSubTypes* класса *CalculateDoseRequest*.

Доступ к Swagger: http://localhost:8901/api/swagger-ui.html

## Логика дозатора

Для каждой ветки дозатора реализуется отдельный сервис. Сервис должен реализовать интерфейс *DispenserProvider* с аргументом *CalculateDoseRequest*, соответствующим ветке дозатора.

Метод *saveAndCalc(input: CalculateDoseRequest)* формирует сущность из DTO, вычисляет результат на основе входных данных и сохраняет результат в базу данных.

## Миграции

Миграции использовались в предыдущих версиях приложения до того, как произошел переход на MongoDB. Между тем, таблица *content* до сих пор находится в базе данных PostgreSQL, поэтому приложению требуются подключения как к MongoDB, так и к PostgreSQL.

Над функционалом *Content* работает фронтендер.


# Deploy (от девопса)
Данная репа содержит в себе весь бэкенд, включая mongo & postgresql.
При этом базы хранятся на диске сервера и при перезапуске сохраняют свое содержание. Mongo - /opt/develop/mongo/data/. Postgresql - /opt/develop/postgresql/data/
Бэк выставлен на http://localhost:8901 и на него смотрит домен https://dozator.dev - настроенный через nginx.
Для работы нужен фронт, он хранится в отдельной репе, при сборке сразу кладется в необходимую папку, нужен лишь перезапуск nginx (systemctl restart nginx) либо релоад конфигурации (nginx -s reload).
Для того чтобы сделать и запустить свежую сборку - делаем git pull (затягиваем изменения, находясь в папке проекта)
Смотрим текущее значение тэга образа в файле docker-compose.yml (вида image: registry.gitlab.com/dozator_lekarstv/dozator-be-mono/dozator-api:11118), можем сразу сменить увеличив на 1.
Запускаем сборку - gradle jar jib -Pdocker.tag=11118(тут новый тег который указали ранее).
Когда соберется тут же docker-compose down и docker-compose up -d 

